using System.Collections.Concurrent;
using Microsoft.Build.Construction;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using Microsoft.CodeAnalysis.Text;
using Roslynator.Analyzer.Enums;
using Roslynator.Analyzer.Models;
using Roslynator.Analyzer.Rules;

namespace Roslynator.Analyzer.Diagnostics
{
    public sealed class ProjectAnalyzer : AnalyzerBase
    {
        public async Task<IReadOnlyCollection<Message>> Analyze(string csproj)
        {
            await Task.Yield();

            AddSection($"Проверка проекта {csproj}");

            ProjectRootElement project = ProjectRootElement.Open(csproj);

            CheckDirectory(project.DirectoryPath);
            CheckProject(project);
            await CheckCode(csproj);

            return GetImportantMessages();
        }

        private void CheckDirectory(string directoryPath)
        {
            Rule<string>[] rules =
            [
                new FileExistsRule(MessageLevel.Warning, "packages.config", "packages.config должен быть преобразован в PackageReference"),
            ];

            Analyze(directoryPath, rules);
        }

        private void CheckProject(ProjectRootElement project)
        {
            Rule<ProjectRootElement>[] rules =
            [
                new RequiredPropertyRule(MessageLevel.Error, "LangVersion", "latest"),
                new UnnecessaryPropertyRule(MessageLevel.Error, "NoWarn"),
                new UnnecessaryPropertyRule(MessageLevel.Error, "CodeAnalysis"),
            ];

            Analyze(project, rules);
        }

        private async Task CheckCode(string csproj)
        {
            Rule<IReadOnlyCollection<SyntaxNode>>[] rules =
            [
                new PragmaWarningDisableRule(MessageLevel.Warning),
                new SuppressMessageAttributeRule(MessageLevel.Warning),
            ];

            IReadOnlyCollection<SyntaxNode> nodes = await GetNodes(csproj);

            Analyze(nodes, rules);
        }

        private static async Task<IReadOnlyCollection<SyntaxNode>> GetNodes(string csproj)
        {
            using MSBuildWorkspace workspace = MSBuildWorkspace.Create();
            Project project = await workspace.OpenProjectAsync(csproj);
            ConcurrentBag<SyntaxNode> result = [];

            IEnumerable<Task> tasks = project.Documents.Select(document => Task.Run(async () =>
            {
                if (!(await IsGenerated(document)))
                {
                    SyntaxTree syntaxTree = (await document.GetSyntaxTreeAsync())!;
                    result.Add(await syntaxTree.GetRootAsync());
                }
            }));

            await Task.WhenAll(tasks);

            return result;
        }

        private static readonly string _obj = $"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}";
        private static readonly string _migrations = $"{Path.DirectorySeparatorChar}Migrations{Path.DirectorySeparatorChar}";

        private static async Task<bool> IsGenerated(Document document)
        {
            string filePath = document.FilePath!;
            if (filePath.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase)
                || filePath.EndsWith(".g.i.cs", StringComparison.OrdinalIgnoreCase)
                || filePath.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase)
                || filePath.Contains(_obj, StringComparison.OrdinalIgnoreCase)
                || filePath.Contains(_migrations))
            {
                return true;
            }

            SourceText sourceText = await document.GetTextAsync();
            if (sourceText.Lines.Count > 0)
            {
                return sourceText.Lines[0].Text!.ToString()
                    .Trim()
                    .Replace(" ", string.Empty)
                    .StartsWith("//<auto-generated/>");
            }

            return false;
        }
    }
}